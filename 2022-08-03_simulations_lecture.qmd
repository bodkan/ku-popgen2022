---
title: "Simulations in population genetics"
format:
  revealjs:
    echo: true
    code-line-numbers: false
    fig-align: center
    slide-number: true
---

```{r, setup}
library(tidyverse)
library(ggplot2)
library(parallel)
library(MASS)
library(forcats)

library(slendr)

set.seed(42)
```

<!-- #  -->

<!-- ::: columns -->
<!-- ::: {.column width="70%"} -->
<!-- > Many problems in population genetics cannot be solved by a mathematician, no matter how gifted. \[It\] is already clear that computer methods are very powerful. This is good. It \[...\] **permits people with limited mathematical knowledge to work on important problems** \[...\] -->
<!-- ::: -->

<!-- ::: {.column width="30%"} -->
<!-- ![](images/crow.jpeg) -->

<!-- [James F. Crow](https://en.wikipedia.org/wiki/James_F._Crow) -->
<!-- ::: -->
<!-- ::: -->

<!-- ## Why simulations? -->

<!-- -   Intuition for behavior of popgen statistics in various scenarios -->
<!-- -   Fitting model parameters against empirical data (i.e. [ABC](https://en.wikipedia.org/wiki/Approximate_Bayesian_computation)) -->
<!-- -   Grand truth for testing and development of statistical methods -->

<!-- ## What does it mean to simulate a genome? -->

<!-- A chromosome is: -->

<!-- -   a linear sequence of nucleotides -->
<!-- -   which accumulates mutations in each generation -->

<!-- ## How do we "get" a genome in real life? -->

<!-- -   A chromosome is a linear sequence of nucleotides. -->
<!-- -   Inherited from generation to generation (maybe with recombination) -->

<!-- # Home-brewed single-locus simulations in R -->

<!-- ## Single-locus simulation -->

<!-- ```{r} -->
<!-- #| results: hide -->
<!-- #| code-line-numbers: "|1-3|5-7|9-10|11|13-14|16-18|20" -->
<!-- N <- 500 # number of (haploid) individuals in the population -->
<!-- generations <- 500 # number of generations to run the simulation for -->
<!-- p_start <- 0.5 # initial allele frequency -->

<!-- # initialize an (empty) trajectory vector of allele frequencies -->
<!-- p_traj<- rep(NA, generations) -->
<!-- p_traj[1] <- p_start -->

<!-- # in each generation... -->
<!-- for (gen_i in 2:generations) { -->
<!--   p <- p_traj[gen_i - 1] # get the current frequency -->

<!--   # ... calculate the allele frequency in the next generation ... -->
<!--   p_next <- rbinom(1, N, p) / N -->

<!--   # ... and save it to the trajectory vector -->
<!--   p_traj[gen_i] <- p_next -->
<!-- } -->

<!-- p_traj -->
<!-- ``` -->

<!-- ## Single-locus simulation ($N$ = 500, $p_0 = 0.5$) -->

<!-- ```{r} -->
<!-- #| code-fold: true -->
<!-- plot(p_traj, type = "l", ylim = c(0, 1), -->
<!--      xlab = "generations", ylab = "allele frequency") -->
<!-- abline(h = p_start, lty = 2, col = "red") -->
<!-- ``` -->

<!-- ## Let's make it a function -->

<!-- **Input:** $N$, $p_0$ and the number of generations -->

<!-- **Output:** allele frequency trajectory vector -->

<!-- ```{r} -->
<!-- simulate <- function(N, p_start, generations) { -->
<!--   # initialize an (empty) trajectory vector of allele frequencies -->
<!--   p_traj<- rep(NA, generations) -->
<!--   p_traj[1] <- p_start -->

<!--   # in each generation... -->
<!--   for (gen_i in 2:generations) { -->
<!--     p <- p_traj[gen_i - 1] # get the current frequency -->
<!--     # ... calculate the allele frequency in the next generation ... -->
<!--     p_next <- rbinom(1, N, p) / N -->
<!--     # ... and save it to the trajectory vector -->
<!--     p_traj[gen_i] <- p_next -->
<!--   } -->

<!--   p_traj -->
<!-- } -->
<!-- ``` -->

<!-- ## $N$ = 500, $p_0 = 0.5$ (20 replicates) -->

<!-- ```{r} -->
<!-- #| code-fold: true -->
<!-- #| fig-align: center -->
<!-- reps <- replicate(20, simulate(N = 500, p_start = 0.5, generations = 2000)) -->

<!-- matplot(reps, ylim = c(0, 1), xlab = "generations", ylab = "allele frequency", type = "l", lty = 1) -->
<!-- ``` -->

<!-- ## $N$ = 1000, $p_0 = 0.5$ (20 replicates) -->

<!-- ```{r} -->
<!-- #| code-fold: true -->
<!-- #| fig-align: center -->
<!-- reps <- replicate(20, simulate(N = 1000, p_start = 0.5, generations = 2000)) -->

<!-- matplot(reps, ylim = c(0, 1), xlab = "generations", ylab = "allele frequency", type = "l", lty = 1) -->
<!-- ``` -->

<!-- ## $N$ = 5000, $p_0 = 0.5$ (20 replicates) -->

<!-- ```{r} -->
<!-- #| code-fold: true -->
<!-- #| fig-align: center -->
<!-- reps <- replicate(20, simulate(N = 5000, p_start = 0.5, generations = 2000)) -->

<!-- matplot(reps, ylim = c(0, 1), xlab = "generations", ylab = "allele frequency", type = "l", lty = 1) -->
<!-- ``` -->

<!-- ## $N$ = 10000, $p_0 = 0.5$ (20 replicates) -->

<!-- ```{r} -->
<!-- #| code-fold: true -->
<!-- #| fig-align: center -->
<!-- reps <- replicate(50, simulate(N = 10000, p_start = 0.5, generations = 20000)) -->

<!-- matplot(reps, ylim = c(0, 1), xlab = "generations", ylab = "allele frequency", type = "l", lty = 1) -->
<!-- ``` -->

<!-- ## $N$ = 10000, $p_0 = 0.5$ (20 replicates) -->

<!-- ```{r} -->
<!-- #| eval: false -->
<!-- #| code-fold: true -->
<!-- #| fig-align: center -->
<!-- factors <- fractions(c(2, 1/2, 1/5, 1/10)) -->
<!-- matplot(reps, ylim = c(0, 1), xlab = "generations", ylab = "allele frequency", type = "l", lty = 1) -->
<!-- abline(v = 10000 * factors, lwd = 5) -->
<!-- ``` -->

<!-- ## Expected allele frequency distribution -->

<!-- ```{r, eval = !file.exists("/tmp/final_frequencies.rds")} -->
<!-- #| eval: false -->
<!-- #| echo: false -->
<!-- p_start <- 0.5 -->
<!-- N <- 10000 -->
<!-- factors <- fractions(c(3, 2, 1, 1/2, 1/5, 1/10)) -->

<!-- final_frequencies <- parallel::mclapply( -->
<!--   seq_along(factors), function(i) { -->
<!--     f <- factors[i] -->
<!--     t <- as.integer(N * f) -->
<!--     # get complete trajectories as a matrix (each column a single trajectory) -->
<!--     reps <- replicate(10000, simulate(N = N, p_start = p_start, generations = t)) -->
<!--     # only keep the last slice of the matrix with the final frequencies -->
<!--     data.frame( -->
<!--       t = sprintf("t = %s * N", f), -->
<!--       freq = reps[t, ] -->
<!--     ) -->
<!--   }, -->
<!--   mc.cores = parallel::detectCores() -->
<!-- ) %>% do.call(rbind, .) -->
<!-- final_frequencies$t <- fct_rev(fct_relevel(final_frequencies$t, sprintf("t = %s * N", factors))) -->

<!-- saveRDS(final_frequencies, "/tmp/final_frequencies.rds") -->
<!-- ``` -->

<!-- ::: columns -->
<!-- ::: {.column width="50%"} -->
<!-- ```{r} -->
<!-- #| eval: false -->
<!-- #| echo: false -->
<!-- #| fig-align: center -->
<!-- #| fig-height: 10 -->
<!-- #| fig-width: 10 -->
<!-- final_frequencies <- readRDS("/tmp/final_frequencies.rds") -->
<!-- final_frequencies$t <- final_frequencies$t -->

<!-- final_frequencies %>% .[.$freq > 0 & .$freq < 1, ] %>% -->
<!-- ggplot() + -->
<!--   geom_histogram(aes(freq, y = ..density.., fill = t), position = "identity", bins = 100, alpha = 0.75) + -->
<!--   labs(x = "allele frequency") + -->
<!--   coord_cartesian(ylim = c(0, 3)) + -->
<!--   facet_grid(t ~ .) + -->
<!--   guides(fill = guide_legend(sprintf("time since\nthe start\n[assuming\nN = %s]", N))) + -->
<!--   theme_minimal() + -->
<!--   theme(strip.text.y = element_blank(), -->
<!--         axis.title.x = element_text(size = 15), -->
<!--         axis.title.y = element_text(size = 15), -->
<!--         axis.text.x = element_text(size = 15), -->
<!--         axis.text.y = element_text(size = 15), -->
<!--         legend.title = element_text(size = 15), -->
<!--         legend.text = element_text(size = 15)) -->
<!-- ``` -->
<!-- ::: -->

<!-- ::: {.column width="50%"} -->
<!-- ::: fragment -->
<!-- ![*"Diffusion Models in Population Genetics"*, [Kimura (1964)](https://www.jstor.org/stable/3211856#metadata_info_tab_contents)](images/kimura.jpeg) -->
<!-- ::: -->
<!-- ::: -->
<!-- ::: -->

<!-- # Bonus exercise -->

<!-- If you're bored later at home... -->

<!-- ## Let's add selection! -->

<!-- Write `simulate_selection(s, N, p_start, generations)`, where `s` is the selection coefficient. -->

<!-- ```{r} -->
<!-- #| eval: false -->
<!-- simulate_selection <- function(s, N, p_start, generations) { -->
<!--   # we assume additivity -->
<!--   h <- 1/2 -->

<!--   # initialize an (empty) trajectory vector of allele frequencies -->
<!--   p_traj<- rep(NA, generations) -->
<!--   p_traj[1] <- p_start -->

<!--   # in each generation... -->
<!--   for (gen_i in 2:generations) { -->
<!--     p <- p_traj[gen_i - 1] # get the current frequency -->

<!--     fitnesses <- c( -->
<!--       p ^ 2           * (1 + s), -->
<!--       2 * p * (1 - p) * (1 + h * s), -->
<!--       (1 - p) ^ 2     * 1 -->
<!--     ) -->
<!--     p_next <- (fitnesses[1] + h * fitnesses[2]) / mean(fitnesses) -->

<!--     if (p_next >= 1) p_next <- 1 -->

<!--     # ... calculate the allele frequency in the next generation ... -->
<!--     p_next <- rbinom(1, N, p_next) / N -->

<!--     # ... and save it to the trajectory vector -->
<!--     p_traj[gen_i] <- p_next -->
<!--   } -->

<!--   p_traj -->
<!-- } -->
<!-- ``` -->

<!-- ```{r} -->
<!-- deterministic_selection <- function(t, p_start, s) { -->
<!--   p_start * exp(s * t / 2) / (p_start * exp(s * t / 2) + (1 - p_start)) -->
<!-- } -->
<!-- ``` -->

<!-- ```{r} -->
<!-- deterministic_traj <- sapply(1:1000, deterministic_selection, p_start = 0.01, s = 0.1) -->

<!-- plot(deterministic_traj, type = "l") -->
<!-- ``` -->

<!-- (Let's assume additive selection: $h = \frac{1}{2}$). -->

<!-- ##  -->

<!-- :::: columns -->

<!-- ::: {.column width="40%"} -->

<!-- <center> -->

<!-- ![](images/feynman.jpeg) -->

<!-- [Richard Feynman](https://en.wikipedia.org/wiki/Richard_Feynman) -->

<!-- </center> -->

<!-- ::: -->

<!-- ::: {.column width="60%"} -->

<!-- ![](images/feynman_quote.png) -->

<!-- ::: -->

<!-- :::: -->

<!-- # {background-image="images/montypython.jpeg"} -->

<!-- <h1 color="white" style="background-color: lightgray;vertical-align: bottom;">But now for something completely different...</h1> -->

<!-- # Let's do "real" simulations -->

<!-- ## There are many pieces of simulation software -->

<!-- The most famous and widely used are ([SLiM](https://messerlab.org/slim/)) and ([msprime](https://tskit.dev/msprime/docs/stable/intro.html)). -->

<!-- ::: fragment -->
<!-- They are both extremely powerful... -->
<!-- ::: -->

<!-- ::: fragment -->
<!-- ... but they require a lot of programming knowledge and quite a lot of code to write non-trivial simulations (without bugs). -->
<!-- ::: -->

<!-- ::: fragment -->
<!-- **We will learn simulation concepts using [*slendr*](http://www.slendr.net), a convenient R interface to both SLiM and msprime.** -->
<!-- ::: -->

<!-- # SLiM -->

<!-- ##  -->

<!-- :::: {.columns} -->

<!-- ::: {.column width="60%"} -->

<!-- <h2>What is SLiM?</h2> -->

<!-- ::: {.fragment} -->
<!-- - **Forward-time simulator** -->
<!-- ::: -->

<!-- ::: {.fragment} -->
<!-- - It's fully programmable! -->
<!-- ::: -->

<!-- ::: {.fragment} -->
<!-- - Massive library of functions for: -->
<!--   - Demographic events -->
<!--   - Various mating systems -->
<!--   - Selection, quantitative traits, ... -->
<!-- ::: -->

<!-- ::: {.fragment} -->
<!-- - \> 700 pages long [manual](https://github.com/MesserLab/SLiM/releases/download/v3.7.1/SLiM_Manual.pdf)! -->
<!-- ::: -->

<!-- ::: -->

<!-- ::: {.column width="40%"} -->

<!-- <center>![Modified from Alex Drummond](images/sim_sketches.001.png){width="100%"}</center> -->

<!-- ::: -->

<!-- :::: -->

<!-- ## SLiMgui -- [IDE](https://en.wikipedia.org/wiki/Integrated_development_environment) for SLiM -->

<!-- <center>![](images/slimgui.png)</center> -->

<!-- ## Simple neutral simulation in SLiM -->

<!-- ```{bash} -->
<!-- #| echo: false -->
<!-- cat script.slim -->
<!-- ``` -->

<!-- # msprime -->

<!-- ## -->

<!-- :::: {.columns} -->

<!-- ::: {.column width="60%"} -->

<!-- <h2>What is [msprime](https://tskit.dev/msprime/docs/stable/intro.html)?</h2> -->

<!-- ::: -->


<!-- ::: {.column width="40%"} -->

<!-- <center>![Modified from Alex Drummond](images/sim_sketches.001.png){width="100%"}</center> -->

<!-- ::: -->

<!-- :::: -->

<!-- ## -->

<!-- :::: {.columns} -->

<!-- ::: {.column width="60%"} -->

<!-- <h2>What is [msprime](https://tskit.dev/msprime/docs/stable/intro.html)?</h2> -->

<!-- ::: {.fragment} -->
<!-- - A Python module for writing **coalescent simulations** -->
<!-- ::: -->

<!-- ::: {.fragment} -->
<!-- - Extremely fast (genome-scale, population-scale data) -->
<!-- ::: -->

<!-- ::: {.fragment} -->
<!-- - You must know Python fairly well to build complex models -->
<!-- ::: -->

<!-- ::: -->

<!-- ::: {.column width="40%"} -->

<!-- <center>![Modified from Alex Drummond](images/sim_sketches.002.png){width="100%"}</center> -->

<!-- ::: -->

<!-- :::: -->

<!-- ## Simple simulation using _msprime_ -->

<!-- &nbsp; -->

<!-- ```{bash} -->
<!-- #| echo: false -->
<!-- cat script.py -->
<!-- ``` -->

<!-- source: [link](https://tskit.dev/msprime/docs/stable/demography.html#demographic-models) -->





















#

<center>

![](images/slendr_logo.png){width="30%"}

<br>

<h2>[www.slendr.net](www.slendr.net)</h2>

</center>

## Why a new package? -- spatial simulations!

::: fragment

<center>
![](images/animation.gif){width="70%"}
</center>

:::

## Why a new package?

::: {.incremental}

-   Most researchers are not expert programmers

-   All but the most trivial simulations require lots of code

-   90% **<citation needed>** of simulations are basically the same!

    - create populations (splits and $N_e$ changes)

    - specify if/how they should mix (rates and times)

    - save output (VCF, EIGENSTRAT)

-   Lot of code duplication across projects

:::

::: fragment
<center>**_slendr_ makes "standard" simulations trivial (for newbies _and_ experts) and unlocks new kinds of spatial simulations**</center>
:::

# Let's get started

## 

```{r}
library(slendr)
```

If you get a message about missing Python modules, run:

```{r}
#| eval: false
setup_env()
```

<center>_(ignore the message about missing SLiM)_</center>

To check that everything is setup correctly, run:

```{r}
check_env()
```



#

<h1>_slendr_ workflow:<br></h1>
<h2>building (complex) models<br>
from simple components</h2>


## Typical steps

<br>

1. creating populations
2. scheduling population splits
3. programming $N_e$ size changes
4. encoding gene-flow events
5. simulation sequence of a given size
6. computing statistics from simulated outputs



## Creating a population

A name, size and the time of appearance must be given:

```{r}
pop1 <- population("pop1", N = 1000, time = 1)
```


. . .

<br>

Typing an object prints out a summary in the R console:

```{r}
pop1
```




## Programming population splits

Splits are programmed using the `parent = <pop>` argument:

```{r}
pop2 <- population("pop2", N = 100, time = 50, parent = pop1)
```


. . .

<br>

The split is reported in the "historical summary":

```{r}
pop2
```




## Scheduling resize events -- `resize()`

Step size decrease:

```{r}
#| code-line-numbers: "2"
pop1 <- population("pop1", N = 1000, time = 1)
pop1_step <- resize(pop1, N = 100, time = 500, how = "step")
```

<br>

Exponential increase:

```{r}
#| code-line-numbers: "2"
pop2 <- population("pop2", N = 100, time = 50, parent = pop1)
pop2_exp <- resize(pop2, N = 10000, time = 500, end = 2000, how = "exponential")
```





## Tidyverse-style pipe interface

Step size decrease:

```{r}
pop1 <-
  population("pop1", N = 1000, time = 1) %>%
  resize(N = 100, time = 500, how = "step")
```

<br>

Exponential increase:

```{r}
pop2 <-
  population("pop2", N = 1000, time = 1) %>%
  resize(N = 10000, time = 500, end = 2000, how = "exponential")
```

<br>

<center>**This accomplishes the same thing as the code on the previous slide, but is more "elegant".**</center>


## Let's assume we have our model...

```{r}
#| code-line-numbers: "|15-20"
pop1 <- population("pop1", N = 1000, time = 1)

pop2 <-
  population("pop2", N = 1000, time = 300, parent = pop1) %>%
  resize(N = 100, how = "step", time = 1000)

pop3 <-
  population("pop3", N = 1000, time = 400, parent = pop2) %>%
  resize(N = 2500, how = "step", time = 800)

pop4 <-
  population("pop4", N = 1500, time = 500, parent = pop3) %>%
  resize(N = 700, how = "exponential", time = 1200, end = 2000)

pop5 <-
  population("pop5", N = 100, time = 600, parent = pop4) %>%
  resize(N = 50, how = "step", time = 900) %>% 
  resize(N = 250, how = "step", time = 1200) %>% 
  resize(N = 1000, how = "exponential", time = 1600, end = 2200) %>% 
  resize(N = 400, how = "step", time = 2400)
```


## Remember: each object carries its history

```{r}
pop5
```




## Last step before simulation: compilation

<br>

```{r}
model <- compile_model(
  list(pop1, pop2, pop3, pop4, pop5),
  generation_time = 1,
  simulation_length = 3000
)
```

<br>

<center>**Compilation takes a list of model components, performs internal consistency checks, returns a single model object.**</center>



## 

```{r}
#| eval: false
pop1 <- population("pop1", N = 1000, time = 1)

pop2 <-
  population("pop2", N = 1000, time = 300, parent = pop1) %>%
  resize(N = 100, how = "step", time = 1000)

pop3 <-
  population("pop3", N = 1000, time = 400, parent = pop2) %>%
  resize(N = 2500, how = "step", time = 800)

pop4 <-
  population("pop4", N = 1500, time = 500, parent = pop3) %>%
  resize(N = 700, how = "exponential", time = 1200, end = 2000)

pop5 <-
  population("pop5", N = 100, time = 600, parent = pop4) %>%
  resize(N = 50, how = "step", time = 900) %>% 
  resize(N = 250, how = "step", time = 1200) %>% 
  resize(N = 1000, how = "exponential", time = 1600, end = 2200) %>% 
  resize(N = 400, how = "step", time = 2400)
```


## Model visualization

```{r}
#| fig-width: 7
#| fig-align: center
plot_model(model)
```





## Simulating data (finally...)

We have the compiled `model`, how do we simulate data?

*slendr* has two simulation engines already built-in:

-   SLiM engine
-   msprime engine

. . . 

<center>**You don't have to write any msprime/SLiM code!**</center>

. . .

Take a model object and use the built-in simulation engine:

```{r, eval = FALSE}
ts <- msprime(model, sequence_length = 100e6, recombination_rate = 1e-8)
```

. . .

<br>
<center>`ts` is a so-called "tree sequence"</center>

# The output of a *slendr* simulation is a **tree sequence**

## What is a tree sequence?

<center>![](images/tree_sequence_diagram.png){width="90%"}</center>

-   A record of full genetic ancestry of a set of samples
-   An encoding of DNA sequence carried by those samples
-   An efficient analysis framework

<center>[from the _tskit_ project](https://tskit.dev/learn.html#what)</center>

# Why a tree sequence?

## What we usually have

<center>![](images/vcf_screenshot.png){width="90%"}</center>

## What we usually *want*

A full representation of the history of all of our samples:

<center>![](images/tree_sequence_diagram.png)</center>

::: fragment
<center>**And this is exactly what tree sequences give us.**</center>
:::

## Let's get back to the model we defined earlier

```{r}
#| fig-align: center
#| echo: false
plot_model(model)
```

## Simulating a tree-sequence output

<br>
By default, `msprime` function automatically loads the tree-sequence that the simulation produced in the background:

<br>

```{r}
ts <- msprime(
  model,
  sequence_length = 10e6,
  recombination_rate = 1e-8
)
```

. . .

<br>

If we type `ts` into an R console, we get...

## ... a tree-sequence content summary

```{r}
ts
```




# What can we do with this?

## R interface to tskit

<center>

![](images/slendr_tskit.png){width="120%"}

This [R interface](https://www.slendr.net/reference/index.html#tree-sequence-loading-and-processing) links to Python methods implemented in [_tskit_](https://tskit.dev/tskit/docs/stable/python-api.html).

</center>


## Here is the magic

Tree sequences make it possible to directly compute many quantities of interest *without going via conversion to a genotype table/VCF*!

<center>![](images/tree_sequence_diagram.png)</center>

# How do we use this in practice?

## Extracting sample information

Each "sampled" individual in _slendr_ has a symbolic name, a sampling time, and a population assignment:

```{r}
#| fig-align: center
#| echo: false
#| fig-width: 8
plot_model(model)
```

## Extracting sample information

Each "sampled" individual in _slendr_ has a symbolic name, a sampling time, and a population assignment:

:::: columns

::: {.column width="55%"}
```{r}
#| output-location: fragment
ts_samples(ts)
```
:::

::: {.column width="2%"}
&nbsp;
:::

::: {.column width="43%"}
```{r}
#| output-location: fragment
ts_samples(ts) %>% count(pop)
```
:::

::::



## Analyzing tree sequences with _slendr_

Let's say we have the following model and we simulate a tree sequence from it.

```{r}
#| code-line-numbers: "|1|2|5|6|4"
pop <- population("pop", N = 10000, time = 100000)
model <- compile_model(pop, generation_time = 1, direction = "backward")

ts <- msprime(model, sequence_length = 10e6, recombination_rate = 1e-8)
```

<br>

<center>**_slendr_ provides a large [library of functions](https://www.slendr.net/reference/index.html#tree-sequence-loading-and-processing) for computing population genetic statistics on tree sequences**</center>

## Example: allele frequency spectrum

```{r}
#| echo: false
set.seed(42)
```

:::: columns

:::  {.column width="55%"}
```{r}
#| code-line-numbers: "|3-6|11-12|14"
# sample 5 individuals
# (i.e. 10 chromosomes)
samples <-
  ts_samples(ts) %>%
  sample_n(5) %>%
  pull(name)

# compute allele frequency
# spectrum from the given set
# of individuals
afs <- ts_afs(
  ts, list(samples),
  mode = "branch",
  span_normalise = TRUE,
  polarised = TRUE
)

afs
```
:::

::: {.column width="2%"}
&nbsp;
:::

::: {.column width="43%"}
::: fragment
```{r}
#| fig-height: 10
plot(afs, type = "b",
     xlab = "allele count bin",
     ylab = "frequency")
```
:::
:::

::::




## But wait, we don't have any mutations!

```{r}
ts
```


## How can we compute statistics?

This is because of the duality between mutations and branch lengths (more [here](https://tskit.dev/tskit/docs/stable/stats.html)).

<center>

![](images/tree_sequence_diagram.png)

<br>

<h3>What if we want mutations?</h3>

</center>

## Adding mutations _after_ the simulation

Coalescent and mutation processes can be decoupled!

<center>

![](images/tree_sequence_diagram.png)

</center>

## This is what allows efficient, massive simulations!

```{r}
ts <- ts_mutate(ts, mutation_rate = 1e-8)

ts
```





## What we have learned so far

1. creating populations -- [`populations()`](https://www.slendr.net/reference/population.html)
2. compiling models -- [`compile_model()`](https://www.slendr.net/reference/compile_model.html)
3. simulating tree sequences -- [`msprime()`](https://www.slendr.net/reference/msprime.html)
4. extracting samples -- [`ts_samples()`](https://www.slendr.net/reference/ts_samples.html)
5. computing AFS -- [`ts_afs()`](https://www.slendr.net/reference/ts_afs.html)

<br>

<center><h1>**Let's put this to use!**</h1></center>




# Exercise #1


## Exercise #1

```{r}
#| echo: false
set.seed(42)
TRUE_NE <- 6543

pop <- population("pop", N = TRUE_NE, time = 100000)
model <- compile_model(pop, generation_time = 1, direction = "backward")

ts <-
  msprime(model, sequence_length = 10e6, recombination_rate = 1e-8, random_seed = 42) %>%
  ts_mutate(mutation_rate = 1e-8, random_seed = 42)

samples <- ts_samples(ts) %>% sample_n(10) %>% pull(name)

observed_afs <- ts_afs(ts, list(samples), polarised = TRUE)
```

Collaborator Hestu gave you AFS computed from 20 individuals of a sub-species of the [_bushy-tailed squirrel_](https://www.zeldadungeon.net/wiki/Bushy-Tailed_Squirrel) discovered in the Forest of Spirits in the land of Hyrule:

```{r}
#| echo: false
dput(as.vector(observed_afs))
```

Fossil evidence is consistent with constant size of the population over 100,000 generations of its history. An Oracle you met in the Temple of Time said that the true squirrel $N_e$ has been between 1000 and 30000.

Use _slendr_ to simulate history of this species. Use this to guess the likely value of squirrel's $N_e$ given the observed AFS.



## Exercise #1 -- hints

1. Write a function that gets $N_e$ as input and returns the AFS.

2. Find the $N_e$ value that will give the closest AFS to the one you got from Hestu. Use whatever method you're comfortable with based on your programming experience:

    - i ) Plot simulated AFS for different $N_e$ with the AFS and just eye-ball $N_e$ value that looks correct.
  
    - ii ) Simulate AFS across a grid of $N_e$ values and find the closest matching one (maybe use [mean-squared error](https://en.wikipedia.org/wiki/Mean_squared_error)?)
  
    - iii ) Run a mini-Approximate Bayesian Computation, using the Oracle's range of [10000, 30000] as a uniform prior.


## Exercise #1 -- simulations on a grid

```{r}
#| output: false
#| code-fold: true
#| code-summary: "Show solution 'ii'"
simulate_afs <- function(Ne) {
  model_path <- tempfile()
  on.exit(unlink(model_path, recursive = TRUE, force = TRUE))

  pop <- population("pop", N = Ne, time = 100000)
  model <- compile_model(pop, generation_time = 1, direction = "backward",
                         path = model_path, overwrite = TRUE, force = TRUE)
  
  ts <-
    msprime(model, sequence_length = 10e6, recombination_rate = 1e-8) %>%
    ts_mutate(mutation_rate = 1e-8)
  
  samples <- ts_samples(ts) %>% sample_n(10) %>% pull(name)
  
  afs <- ts_afs(ts, list(samples), polarised = TRUE)
  
  afs
}

Ne_grid <- seq(from = 1000, to = 30000, by = 1000)

afs_grid <- lapply(Ne_grid, simulate_afs)

afs_observed <- c(2520, 1449, 855, 622, 530, 446, 365, 334, 349, 244, 264, 218, 
133, 173, 159, 142, 167, 129, 125, 143)

# Plot the observed AFS and overlay the simulated AFS vectors on top of it
plot(afs_observed, type = "b", col = "red", lwd = 3)
for (i in seq_along(Ne_grid)) {
  lines(afs_grid[[i]], lwd = 0.5)
}

# Compute mean-squared error of the AFS produced by each Ne value across the grid
errors <- sapply(afs_grid, function(afs) {
  sum((afs - afs_observed)^2) / length(afs)
})

# plot the errors, highlight the most likely value
plot(Ne_grid, errors)
abline(v = Ne_grid[which.min(errors)], col = "green")
abline(v = TRUE_NE, col = "purple")
legend("topright", legend = c(paste("inferred Ne =", Ne_grid[which.min(errors)]),
                              paste("true Ne =", TRUE_NE)),
       col = c("green", "purple"), lty = 2)

# Plot the AFS again, highlighting the most likely spectrum
plot(afs_observed, type = "b", col = "red", lwd = 1)
for (i in seq_along(Ne_grid)) {
  color <- if (i == which.min(errors)) "green" else "gray"
  width <- if (i == which.min(errors)) 2 else 0.5
  lines(afs_grid[[i]], lwd = width, col = color)
}
legend("topright", legend = paste("Ne =", Ne_grid[which.min(errors)]),
       col = "green", lty = 2)
```



## Exercise #1 -- ABC inference

```{r}
#| code-fold: true
#| code-summary: "Show solution 'iii'"
# Compute a single AFS given input Ne sampled from the prior, return the
# error vs observed AFS together with the Ne
compute_Ne_error <- function(Ne) {
  prior <- seq(1000, 30000, by = 1)
  Ne <- sample(prior, 1)

  afs <- simulate_afs(Ne)

  error <- sum((afs - afs_observed)^2) / length(afs)

  data.frame(
    Ne = Ne,
    error = error
  )
} 

run_abc <- function(n_iterations, afs_observed) {
  # generate a list of all individual ABC runs (pairs Ne-vs-error)
  abc_runs <- mclapply(1:n_iterations, compute_Ne_error)
  # join all runs into a single data frame and return it 
  abc_df <- do.call(rbind, abc_runs)
  abc_df
}

if (file.exists("data/abc_results.rds")) {
  abc_results <- readRDS("data/abc_results.rds")
} else {
  abc_results <- run_abc(1000, afs_observed)
  saveRDS(abc_results, "data/abc_results.rds")
}


error_cutoff <- quantile(abc_results$error, 0.05)

ggplot(abc_results, aes(Ne)) +
  geom_histogram(bins = 100) +
  ggtitle("Prior Ne distribution") +
  xlim(1000, 30000)

ggplot(abc_results[abc_results$error < error_cutoff, ], aes(Ne)) +
  geom_histogram(bins = 100) +
  geom_vline(xintercept = TRUE_NE, color = "red") +
  ggtitle("Posterior Ne distribution") +
  xlim(1000, 30000)

# summarise the 95% HPD interval of the Ne
filter(abc_results, error < error_cutoff) %>% pull(Ne) %>% summary

TRUE_NE
```



## Exercise #2

:::: columns

::: {.column width="60%"}
Tectonic shifts caused by activated Sheikah towers caused speciation of the squirrels. Unfortunately, their future is clouded by the shadow cast over Hyrule by Calamity Ganon.

Can you help the Oracle predict the future shape of the AFS of the squirrels, assuming starting $N_e$ = 6543? Species #1 will remain constant, species #2 will expand 3X, species #3 will get 3X smaller.

:::

::: {.column width="40%"}
```{r}
#| echo: false
#| fig-height: 13
Ne_start <- 6543
Ne_factor <- 3

pop1 <- population("s1", N = Ne_start, time = 1)

pop2 <-
  population("s2", N = Ne_start, time = 2, parent = pop1) %>%
  resize(how = "step", N = as.integer(Ne_factor * Ne_start), time = 5000)

pop3 <-
  population("s3", N = Ne_start, time = 2, parent = pop1) %>%
  resize(how = "step", N = as.integer(Ne_start / Ne_factor), time = 5000)

model <- compile_model(
  populations = list(pop1, pop2, pop3),
  generation_time = 1,
  simulation_length = 10000
)

plot_model(model)
```

:::

::::

## Exercise #2 -- solution


```{r}
#| code-fold: true
#| code-summary: "Show solution"
#| fig-align: center
#| fig-width: 10
Ne_start <- 6543
Ne_factor <- 3

pop1 <- population("s1", N = Ne_start, time = 1)

pop2 <-
  population("s2", N = Ne_start, time = 2, parent = pop1) %>%
  resize(how = "step", N = as.integer(Ne_factor * Ne_start), time = 5000)

pop3 <-
  population("s3", N = Ne_start, time = 2, parent = pop1) %>%
  resize(how = "step", N = as.integer(Ne_start / Ne_factor), time = 5000)

model <- compile_model(
  populations = list(pop1, pop2, pop3),
  generation_time = 1,
  simulation_length = 10000
)

ts <-
  msprime(model, sequence_length = 10e6, recombination_rate = 1e-8) %>%
  ts_mutate(mutation_rate = 1e-8)

samples <- ts_samples(ts) %>%
  group_by(pop) %>%
  sample_n(20)

pop1_names <- filter(samples, pop == "s1")$name
pop2_names <- filter(samples, pop == "s2")$name
pop3_names <- filter(samples, pop == "s3")$name

afs1 <- ts_afs(ts, list(pop1_names), polarised = TRUE)
afs2 <- ts_afs(ts, list(pop2_names), polarised = TRUE)
afs3 <- ts_afs(ts, list(pop3_names), polarised = TRUE)

plot(afs2, type = "l", col = "blue", cex = 0.2, xlab = "allele count bin", ylab = "frequency")
lines(afs1, type = "l", cex = 0.2)
lines(afs3, type = "l", col = "green", cex = 0.2)
legend("topright", legend = c("constant", "expansion", "contraction"),
       fill = c("black", "blue", "green"))
```






# What else can _slendr_ do?




## Gene flow events

Gene flow is programmed using the `gene_flow()` function:

```{r}
gf <- gene_flow(from = pop1, to = pop2, start = 500, end = 600, rate = 0.13)
```

. . .

<br>

Multiple gene-flow events can be gathered in a list:

```{r}
gf <- list(
  gene_flow(from = pop1, to = pop2, start = 500, end = 600, rate = 0.13),
  gene_flow(from = pop2, to = pop1, start = 700, end = 750, rate = 0.1)
)
```


. . .

<br>
<center>**`gene_flow()` checks admixture events for consistency**</center>




## Let's build another more complex model

```{r}
#| output-location: fragment
#| fig-width: 7
#| fig-align: center
#| echo: false
o <- population("o", time = 1, N = 100)
c <- population("c", time = 2500, N = 500, parent = o)
a <- population("a", time = 3000, N = 2000, parent = c)
b <- population("b", time = 3500, N = 4000, parent = a)
x1 <- population("x1", time = 3800, N = 8000, parent = c)
x2 <- population("x2", time = 4000, N = 10000, parent = x1)

gf <- gene_flow(from = b, to = x1, start = 5100, end = 5400, rate = 0.3)

model <- compile_model(
  populations = list(a, b, x1, x2, c, o), gene_flow = gf,
  generation_time = 1, simulation_length = 7000
)

plot_model(model, proportions = TRUE)

ts <- msprime(model, sequence_length = 25e6, recombination_rate = 1e-8) %>%
  ts_mutate(mutation_rate = 1e-8)
```


```{r}
#| echo: false
f4_model_path <- file.path(tempdir(), "f4model")

model <- compile_model(
  populations = list(a, b, x1, x2, c, o), gene_flow = gf,
  generation_time = 1, simulation_length = 7000,
  path = f4_model_path, overwrite = TRUE, force = TRUE
)
```


## Diversity -- `ts_diversity()`

:::: {.columns}

```{r}
samples <-
  ts_samples(ts) %>%
  split(., .$pop) %>%
  lapply(pull, "name")
```

<br>

```{r}
ts_diversity(ts, samples) %>% arrange(diversity)
```

::::



# Exercise #3

## Program the following model in *slendr*

```{r}
#| code-fold: true
#| code-summary: "Show a solution"

chimp <- population("CH", time = 7e6, N = 7000)

afr <- population("AFR", parent = chimp, time = 6e6, N = 10000)
eur <- population("EUR", parent = afr, time = 70e3, N = 5000)

alt <- population("ALT", parent = afr, time = 700e3, N = 500)
vi <- population("VI", parent = alt, time = 120e3, N = 1000)

gf <- gene_flow(from = vi, to = eur, rate = 0.03, start = 50000, end = 40000)

model <- compile_model(
  populations = list(chimp, alt, vi, afr, eur), gene_flow = gf,
  generation_time = 30
)
```

```{r}
#| echo: false
#| fig-align: center
title <- theme(plot.title = element_text(size=22))

cowplot::plot_grid(
  plot_model(model) + ggtitle("Normal time scale") + title,
  plot_model(model, log = TRUE, proportions = TRUE) + ggtitle("Time on the log-scale") + title
)
```

## Parameter values

-   "CH" outgroup population at time 7 Mya ($N_e$ = 7k)

-   "AFR" population splitting from "CH" at 6 Mya ($N_e$ = 10k)

-   "ALT" population splitting from "AFR" at 700 kya ($N_e$ = 500)

-   "VI" population splitting from "ALT" at 120 kya ($N_e$ = 1k)

-   "EUR" population splitting from "AFR" at 70 kya ($N_e$ = 5k)

-   gene flow from "VI" to "EUR" at 3% over 50-40 kya

Then simulate 100Mb sequence with `msprime()`, using recombination rate 1e-8 per bp per generation.





## Exercise #4

:::: columns

::: {.column width="40%"}
Use the _slendr_ function `ts_diversity()` to compute nucleotide diversity in each simulated population (`CH`, `AFR`, ...).

Does the result correspond to what you would expect based on the programmed demographic history?

What about pairwise genetic divergence between all populations (`ts_divergence()`)? Do your results recapitulate phylogenetic relationships from the figure?
:::

::: {.column}
```{r}
#| echo: false
plot_model(model, log = TRUE, proportions = TRUE)
```
:::




## Exercise #4 -- solution (diversity)

```{r}
#| code-fold: true
ts <-
  msprime(model, sequence_length = 50e6, recombination_rate = 1e-8) %>%
  ts_mutate(mutation_rate = 1e-8)

sample_names <- ts_samples(ts) %>% split(., .$pop) %>% lapply(pull, "name")

ts_diversity(ts, sample_sets = sample_names) %>% arrange(diversity)
```





## Exercise #4 -- solution (divergence)

:::: columns

::: column
```{r}
#| code-fold: true
divergence <-
  ts_divergence(ts, sample_names) %>%
  arrange(divergence)

divergence
```
:::

::: column
```{r}
#| code-fold: true
divergence %>%
  mutate(pair = paste(x, "-", y),
         pair = fct_reorder(pair, divergence)) %>%
  ggplot(aes(pair, divergence)) +
  geom_point() +
  labs(x = "", y = "divergence") +
  ggtitle("Pairwise genetic divergence between populations") +
  theme_minimal()
```

:::

::::







## Sampling "ancient DNA" time-series

By default, _slendr_ records every individual living at the end of the simulation. Sampling can be also scheduled explicitly:

::: fragment

```{r}
model <- read_model(f4_model_path)
```

```{r}
#| code-line-numbers: "1-4|6-9|11"
x_schedule <- schedule_sampling(
  model, times = seq(from = 7000, to = 4000, by = -100),
  list(x1, 5), list(x2, 5)
)

abco_schedule <- schedule_sampling(
  model, times = 7000,
  list(a, 1), list(b, 1), list(c, 1), list(o, 1)
)

schedule <- rbind(x_schedule, abco_schedule)
```

:::

::: fragment
The schedule can be used in an `msprime()` call like this:

```{r}
ts <- msprime(model, sequence_length = 50e6, recombination_rate = 1e-8,
              samples = schedule)
```

:::



## Computing $f_4$ statistic



:::: columns

::: {.column width="60%"}

```{r}
#| echo: false
#| fig-height: 8
plot_model(model)
```

:::

::: {.column width="40%"}

Having simulated data from this model, can we detect gene flow from _b_ into _x1_ as we have learned in the lecture on $f$-statistics?

:::

::::



## Computing $f_4$ statistic -- `ts_f4()`

```{r}
ts <-
  msprime(model, samples = schedule,
          sequence_length = 50e6, recombination_rate = 1e-8) %>%
  ts_mutate(mutation_rate = 1e-8)
```

. . .
<br>

```{r}
ts_f4(ts, "x2_1", "x1_1", "b_1" , "o_1")
```

. . .
<br>
```{r}
ts_f4(ts, "x2_100", "x1_100", "b_1" , "o_1")
```


## Computing $f_4$ statistic for all `x` individuals

```{r}
x_inds <- ts_samples(ts) %>% filter(pop %in% c("x1", "x2"))

x_names <- x_inds$name

f4_result<- map_dfr(x_names, function(w) ts_f4(ts, W = w, X = "c_1", Y = "b_1" , Z = "o_1"))

x_inds$f4 <- f4_result$f4
```

```{r}
#| code-fold: true
ggplot(x_inds) +
  geom_rect(aes(xmin = 5100, xmax = 5400, ymin = -Inf, ymax = Inf), alpha = 0.75, fill = "gray") +
  geom_jitter(aes(time, f4, color = pop)) +
  geom_line(data = . %>% group_by(pop, time) %>% summarise(f4 = mean(f4)),
            aes(time, f4, color = pop), size = 2) +
  geom_hline(yintercept = 0, linetype = 2, size = 1)
```









# Exercise #X

## Compute $f_4$-ratio estimate of Neanderthal ancestry

- Schedule sampling of early-modern
# Bonus exercise

## Try to implement something relevant for your work

-   Program a demographic model for your species of interest
-   Compute a statistic whose value you "know" (diversity? f4-statistic? divergence?) and try to replicate it




## _Simplifying_ a tree sequence

```{r}
#| echo: false
model <- read_model(f4_model_path)
ts <- msprime(model, sequence_length = 50e6, recombination_rate = 1e-8)
```

```{r}
ts_small <- ts_simplify(ts, simplify_to = c("o_1", "a_1", "b_1", "c_1", "x1_1", "x2_1"))

ts_small
```

## Extracting a tree

```{r}
tree <- ts_phylo(ts_small, 42)

tree
```

## Plotting a tree

```{r}
library(ape)

plot(tree)
nodelabels()
```



<!-- ## Exercise #5 -- solution -->

<!-- ```{r} -->
<!-- ts_small <- ts_simplify( -->
<!--   ts, -->
<!--   simplify_to = c("CH_1", "AFR_1", "ALT_1", "VI_1", -->
<!--                   paste0("EUR_", 1:5)) -->
<!-- ) -->

<!-- ts_small -->
<!-- ``` -->


<!-- ```{r} -->
<!-- tree <- ts_phylo(ts_small, 1000) -->

<!-- nodes <- ts_nodes(tree) -->
<!-- df <- as_tibble(nodes) %>% select(node = phylo_id, pop) -->

<!-- p_tree <- ggtree(tree) %<+% df + -->
<!--   geom_tiplab(aes(color = pop, fill = pop)) + -->
<!--   guides(color = "none") + -->
<!--   scale_x_continuous(limits = c(-7e6, 900e3)); revts(p_tree) -->
<!-- ``` -->

